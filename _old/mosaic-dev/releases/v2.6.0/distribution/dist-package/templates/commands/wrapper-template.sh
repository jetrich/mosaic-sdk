#!/bin/bash

# Tony Command Wrapper Template
# Generated by Tony Framework v2.6.0
# Command: {{COMMAND_NAME}}
# Description: {{COMMAND_DESCRIPTION}}
# Generated: {{GENERATION_TIMESTAMP}}

set -euo pipefail

# ============================================================================
# TEMPLATE PLACEHOLDERS (replaced during generation)
# ============================================================================
COMMAND_NAME="{{COMMAND_NAME}}"
COMMAND_DESCRIPTION="{{COMMAND_DESCRIPTION}}"
USER_TONY_PATH="{{USER_TONY_PATH}}"
PROJECT_CONTEXT_FILE="{{PROJECT_CONTEXT_FILE}}"
COMMAND_ARGS="{{COMMAND_ARGS}}"
HOOK_FUNCTIONS="{{HOOK_FUNCTIONS}}"

# ============================================================================
# COMMAND WRAPPER INFRASTRUCTURE  
# ============================================================================

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source Tony library utilities
if [ -f "$SCRIPT_DIR/../scripts/lib/tony-lib.sh" ]; then
    source "$SCRIPT_DIR/../scripts/lib/tony-lib.sh"
    source "$SCRIPT_DIR/../scripts/lib/delegation-logic.sh"
elif [ -f "$HOME/.tony/lib/tony-lib.sh" ]; then
    source "$HOME/.tony/lib/tony-lib.sh"
    source "$HOME/.tony/lib/delegation-logic.sh"
else
    echo "ERROR: Tony library not found. Please install Tony Framework."
    exit 1
fi

# ============================================================================
# PRE-COMMAND HOOKS
# ============================================================================

# Pre-command validation hook
pre_command_hook() {
    log_debug "Executing pre-command hook for $COMMAND_NAME"
    
    # {{PRE_COMMAND_HOOK_CONTENT}}
    
    # Validate user Tony installation
    if [ ! -f "$USER_TONY_PATH" ]; then
        log_error "User Tony not found at: $USER_TONY_PATH"
        log_info "Please install Tony Framework: curl -fsSL https://tony.jetrich.com/install | bash"
        return 1
    fi
    
    # Prepare context for delegation
    prepare_command_context
    
    return 0
}

# Prepare context for command delegation
prepare_command_context() {
    log_debug "Preparing context for command delegation"
    
    # Create context data structure
    local context_data=$(cat <<EOF
{
    "command": "$COMMAND_NAME",
    "description": "$COMMAND_DESCRIPTION", 
    "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
    "project_path": "$(pwd)",
    "git_branch": "$(git branch --show-current 2>/dev/null || echo 'unknown')",
    "git_status": "$(git status --porcelain 2>/dev/null | wc -l || echo '0')",
    "args": [$(printf '"%s",' "$@" | sed 's/,$//')]
}
EOF
    )
    
    # Save context to temporary file
    local context_file="${PROJECT_CONTEXT_FILE:-$HOME/.tony/tmp/command-context-$$.json}"
    echo "$context_data" > "$context_file"
    export TONY_COMMAND_CONTEXT="$context_file"
    
    log_debug "Context saved to: $context_file"
}

# ============================================================================
# COMMAND DELEGATION
# ============================================================================

# Execute command via enhanced delegation
delegate_to_user_tony() {
    log_info "Delegating $COMMAND_NAME to user Tony installation (enhanced)"
    
    # Use enhanced delegation logic with fallback handling
    if delegate_command_enhanced "$COMMAND_NAME" "$USER_TONY_PATH" "$TONY_COMMAND_CONTEXT" "$@"; then
        log_success "Enhanced delegation completed successfully"
        return 0
    else
        local exit_code=$?
        log_error "Enhanced delegation failed with exit code: $exit_code"
        return $exit_code
    fi
}

# ============================================================================
# POST-COMMAND HOOKS
# ============================================================================

# Post-command cleanup hook
post_command_hook() {
    local exit_code=$1
    log_debug "Executing post-command hook for $COMMAND_NAME (exit: $exit_code)"
    
    # {{POST_COMMAND_HOOK_CONTENT}}
    
    # Cleanup context file
    if [ -n "${TONY_COMMAND_CONTEXT:-}" ] && [ -f "$TONY_COMMAND_CONTEXT" ]; then
        rm -f "$TONY_COMMAND_CONTEXT"
        log_debug "Cleaned up context file: $TONY_COMMAND_CONTEXT"
    fi
    
    # Log command completion
    log_info "Command $COMMAND_NAME finished with exit code: $exit_code"
    
    return 0
}

# ============================================================================
# ERROR HANDLING
# ============================================================================

# Handle missing user Tony installation
handle_missing_tony() {
    log_error "User Tony Framework not found"
    echo
    echo "To install Tony Framework:"
    echo "  curl -fsSL https://tony.jetrich.com/install | bash"
    echo
    echo "Or install manually:"
    echo "  git clone https://github.com/jetrich/tony ~/.tony"
    echo "  ~/.tony/install.sh"
    echo
    exit 1
}

# Handle command errors
handle_command_error() {
    local exit_code=$1
    local error_msg="${2:-Unknown error}"
    
    log_error "Command failed: $error_msg"
    
    # Try to provide helpful debugging information
    if [ -n "${TONY_COMMAND_CONTEXT:-}" ] && [ -f "$TONY_COMMAND_CONTEXT" ]; then
        log_debug "Command context available at: $TONY_COMMAND_CONTEXT"
    fi
    
    # Clean up and exit
    post_command_hook $exit_code
    exit $exit_code
}

# ============================================================================
# MAIN COMMAND EXECUTION
# ============================================================================

# Main wrapper function
main() {
    # Initialize logging
    init_tony_lib
    
    log_info "Tony Command Wrapper: $COMMAND_NAME"
    log_debug "Description: $COMMAND_DESCRIPTION"
    
    # Set up error handling
    trap 'handle_command_error $? "Unexpected error"' ERR
    
    # Execute pre-command hooks
    if ! pre_command_hook "$@"; then
        handle_command_error 1 "Pre-command hook failed"
    fi
    
    # Check if user Tony exists
    if [ ! -f "$USER_TONY_PATH" ]; then
        handle_missing_tony
    fi
    
    # Delegate command to user Tony
    if delegate_to_user_tony "$@"; then
        local exit_code=0
    else
        local exit_code=$?
    fi
    
    # Execute post-command hooks
    post_command_hook $exit_code
    
    exit $exit_code
}

# ============================================================================
# COMMAND-SPECIFIC CUSTOMIZATIONS
# ============================================================================

{{CUSTOM_FUNCTIONS}}

# ============================================================================
# ENTRY POINT
# ============================================================================

# Only run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi