# E055 Vulnerability Reference Guide

**Purpose**: Quick reference for agents implementing security fixes  
**Scope**: @mosaic/core package vulnerabilities  

## ðŸš¨ Critical Vulnerabilities

### 1. Command Injection in MCPClient.ts

**Location**: `/src/coordinators/MCPClient.ts:72`

**Vulnerable Code**:
```typescript
this.serverProcess = spawn('node', [this.serverPath], {
  stdio: ['pipe', 'pipe', 'pipe'],
  env: {
    ...process.env,
    DATABASE_PATH: this.config.databasePath || path.join(process.cwd(), '.mosaic/data/mcp.db'),
    PORT: this.config.port?.toString() || '3001'
  }
});
```

**Issues**:
- `this.serverPath` is not validated - could contain malicious input
- Environment variables passed directly without sanitization
- No validation of executable path

**Fix Requirements**:
1. Validate `serverPath` against whitelist of allowed executables
2. Ensure path is absolute and within project boundaries
3. Sanitize all environment variables
4. Use `execFile` instead of `spawn` for better security
5. Implement process isolation

**Secure Implementation Example**:
```typescript
import { execFile } from 'child_process';
import { isAbsolute, normalize, relative } from 'path';

// Validate server path
const validateServerPath = (path: string): boolean => {
  const normalized = normalize(path);
  const allowedPaths = [
    '/mosaic-mcp/dist/main.js',
    '/node_modules/@tony-framework/mcp/dist/main.js'
  ];
  
  return allowedPaths.some(allowed => normalized.endsWith(allowed));
};

// Sanitize environment variables
const sanitizeEnv = (env: Record<string, any>): Record<string, string> => {
  const sanitized: Record<string, string> = {};
  const allowedEnvVars = ['DATABASE_PATH', 'PORT', 'NODE_ENV'];
  
  for (const [key, value] of Object.entries(env)) {
    if (allowedEnvVars.includes(key)) {
      sanitized[key] = String(value).replace(/[^\w\-\.\/]/g, '');
    }
  }
  
  return sanitized;
};
```

### 2. Path Traversal Vulnerabilities

**Locations**: 
- `/src/coordinators/MCPClient.ts:45,47,75,99`

**Vulnerable Code**:
```typescript
// Line 45
path.join(__dirname, '../../../../mosaic-mcp/dist/main.js'),

// Line 75 & 99
DATABASE_PATH: this.config.databasePath || path.join(process.cwd(), '.mosaic/data/mcp.db'),
```

**Issues**:
- No validation of user-provided paths
- Potential for directory traversal attacks
- Could access files outside intended directories

**Fix Requirements**:
1. Validate all paths are within project root
2. Normalize paths to prevent `../` traversal
3. Use a secure path resolver utility
4. Never trust user input for file paths

**Secure Implementation Example**:
```typescript
import { resolve, relative, isAbsolute, sep } from 'path';

class SecurePathResolver {
  private projectRoot: string;
  
  constructor(projectRoot: string) {
    this.projectRoot = resolve(projectRoot);
  }
  
  resolveSafe(inputPath: string): string {
    const resolved = resolve(this.projectRoot, inputPath);
    const relativePath = relative(this.projectRoot, resolved);
    
    // Ensure the path doesn't escape project root
    if (relativePath.startsWith('..') || isAbsolute(relativePath)) {
      throw new Error('Path traversal attempt detected');
    }
    
    // Additional check for null bytes and other attacks
    if (inputPath.includes('\0') || inputPath.includes('%00')) {
      throw new Error('Null byte injection detected');
    }
    
    return resolved;
  }
}
```

### 3. Memory Leaks

**Locations**: Multiple files

#### 3.1 Event Listener Leaks in MCPClient.ts

**Vulnerable Code**:
```typescript
// Lines 83-89
this.serverProcess.on('error', (error) => {
  console.error('MCP server error:', error);
  reject(error);
});

this.serverProcess.on('close', (code) => {
  console.log(`MCP server exited with code ${code}`);
});
```

**Issue**: Event listeners added but never removed

**Fix**:
```typescript
class MCPClient {
  private listeners: Array<{ target: any; event: string; handler: Function }> = [];
  
  private addEventListener(target: any, event: string, handler: Function) {
    target.on(event, handler);
    this.listeners.push({ target, event, handler });
  }
  
  async dispose() {
    // Remove all listeners
    for (const { target, event, handler } of this.listeners) {
      target.removeListener(event, handler);
    }
    this.listeners = [];
    
    // Kill server process
    if (this.serverProcess && !this.serverProcess.killed) {
      this.serverProcess.kill();
    }
  }
}
```

#### 3.2 Timeout Leaks in WorkflowEngine.ts

**Vulnerable Code**:
```typescript
// Line 258
const timeout = setTimeout(() => {
  this.executeWorkflowSteps(workflowId).catch(err => {
    console.error(`Error executing workflow ${workflowId}:`, err);
  });
}, 1000);
```

**Issue**: Timeout not always cleared on all code paths

**Fix**:
```typescript
class WorkflowEngine {
  private activeTimeouts = new Map<string, NodeJS.Timeout>();
  
  private setWorkflowTimeout(workflowId: string, callback: () => void, delay: number) {
    // Clear existing timeout if any
    this.clearWorkflowTimeout(workflowId);
    
    const timeout = setTimeout(() => {
      this.activeTimeouts.delete(workflowId);
      callback();
    }, delay);
    
    this.activeTimeouts.set(workflowId, timeout);
  }
  
  private clearWorkflowTimeout(workflowId: string) {
    const timeout = this.activeTimeouts.get(workflowId);
    if (timeout) {
      clearTimeout(timeout);
      this.activeTimeouts.delete(workflowId);
    }
  }
  
  destroy() {
    // Clear all timeouts
    for (const timeout of this.activeTimeouts.values()) {
      clearTimeout(timeout);
    }
    this.activeTimeouts.clear();
  }
}
```

#### 3.3 EventBus Memory Leak

**Location**: `/src/core/MosaicCore.ts:88`

**Issue**: Event handlers registered but no cleanup method

**Fix**:
```typescript
class EventBus {
  private handlers = new Map<string, Set<Function>>();
  
  on(event: string, handler: Function): () => void {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, new Set());
    }
    this.handlers.get(event)!.add(handler);
    
    // Return unsubscribe function
    return () => {
      this.handlers.get(event)?.delete(handler);
    };
  }
  
  removeAllListeners(event?: string) {
    if (event) {
      this.handlers.delete(event);
    } else {
      this.handlers.clear();
    }
  }
}
```

## ðŸ§ª Testing Requirements

### Security Test Cases

1. **Command Injection Tests**:
   - Test with malicious paths: `../../etc/passwd`
   - Test with shell commands: `; rm -rf /`
   - Test with null bytes: `file.js\0.txt`
   - Test with URL encoded attacks

2. **Path Traversal Tests**:
   - Test with `../` sequences
   - Test with absolute paths
   - Test with symbolic links
   - Test with Unicode normalization attacks

3. **Memory Leak Tests**:
   - Create/destroy 1000 instances
   - Monitor heap usage over time
   - Verify all listeners are removed
   - Check for dangling timeouts

### Code Coverage Requirements

Each fixed file must achieve:
- **Line Coverage**: â‰¥85%
- **Branch Coverage**: â‰¥80%
- **Function Coverage**: 100%
- **Statement Coverage**: â‰¥85%

## ðŸ”’ Security Checklist

Before marking any security task complete:

- [ ] Input validation implemented
- [ ] Output encoding where needed
- [ ] Principle of least privilege applied
- [ ] Defense in depth (multiple layers)
- [ ] Fail securely (errors don't expose info)
- [ ] All user input treated as untrusted
- [ ] Security tests written and passing
- [ ] Code reviewed by security expert
- [ ] No sensitive data in logs
- [ ] Resource limits implemented

## ðŸ“š References

- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)
- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)
- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)
- [Memory Leak Detection Guide](https://nodejs.org/en/docs/guides/diagnostics/memory-leaks/)

---

**Remember**: Security is not optional. Every fix must be thoroughly tested and reviewed.